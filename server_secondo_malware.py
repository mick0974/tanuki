import socket
import threading
import hashlib

import rsa

HOST = "10.0.2.5"
PORT = 6000
MAX_BUFFER_SIZE = 2048

MAX_KEY_REQUESTS = 3


def format_address(client_address):
    return f"{client_address[0]}:{client_address[1]}"


def listen_to_client(client_socket, client_address, private_key, public_key):
    aes_key = None
    aes_iv = None

    key_requests = 0

    while True:
        encrypted_message = client_socket.recv(MAX_BUFFER_SIZE)

        if not encrypted_message:
            print(f"Connection interrupted by client from {format_address(client_address)}")
            client_socket.close()
            break

        operation = rsa.decrypt(encrypted_message, private_key)

        end_request = False

        if operation == b"retrieve":
            print(f"Received request for decryption key from {format_address(client_address)}")
            aes_hash = hashlib.sha256(aes_key + aes_iv).digest()

            aes_key_encrypted = rsa.encrypt(aes_key, public_key)
            aes_iv_encrypted = rsa.encrypt(aes_iv, public_key)
            aes_hash_encrypted = rsa.encrypt(aes_hash, public_key)

            print(f"Sending decryption key to {format_address(client_address)}")
            client_socket.sendall(aes_key_encrypted)
            client_socket.sendall(aes_iv_encrypted)
            client_socket.sendall(aes_hash_encrypted)
        elif operation == b"store" and key_requests < MAX_KEY_REQUESTS:
            key_requests += 1

            print(f"Received key storing request from {format_address(client_address)}")

            aes_key_encrypted = client_socket.recv(MAX_BUFFER_SIZE)
            aes_iv_encrypted = client_socket.recv(MAX_BUFFER_SIZE)
            aes_hash_encrypted = client_socket.recv(MAX_BUFFER_SIZE)

            aes_key = rsa.decrypt(aes_key_encrypted, private_key)
            aes_iv = rsa.decrypt(aes_iv_encrypted, private_key)
            aes_hash = rsa.decrypt(aes_hash_encrypted, private_key)

            calculated_hash = hashlib.sha256(aes_key + aes_iv)

            if aes_hash == calculated_hash.digest():
                print(f"AES decryption key successfully stored for {format_address(client_address)}")
                answer = "keySuccess"
            else:
                print(f"AES decryption key hashes do not match for {format_address(client_address)}")
                answer = "keyFailure"

            print(f"Sending feedback for storing outcome to {format_address(client_address)}")
            encrypted_answer = rsa.encrypt(bytes(answer, encoding="utf-8"), public_key)
            client_socket.sendall(encrypted_answer)
        elif operation == b"endRequest" or key_requests >= MAX_KEY_REQUESTS:
            end_request = True
        else:
            print(f"Incorrect operation request received from {format_address(client_address)}")
            end_request = True

        if end_request:
            print(f"Closing client socket for {format_address(client_address)}")
            client_socket.close()
            break


def start_server():
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind((HOST, PORT))
    server_socket.listen(10)

    print(f"Server listening on {HOST}:{PORT}")

    with open("./RSA_KEYS/TestPrivateKey_SERVER", "rb") as file:
        byte = file.read()

    private_key = rsa.PrivateKey.load_pkcs1(byte, "DER")

    with open("./RSA_KEYS/TestPublicKey_CLIENT", "rb") as file:
        byte = file.read()

    public_key = rsa.PublicKey.load_pkcs1(byte, "DER")

    while True:
        client_socket, client_address = server_socket.accept()
        print(f"Accepted connection from {format_address(client_address)}")

        threading.Thread(target=listen_to_client, args=(client_socket, client_address, private_key, public_key)).start()


if __name__ == "__main__":
    start_server()
